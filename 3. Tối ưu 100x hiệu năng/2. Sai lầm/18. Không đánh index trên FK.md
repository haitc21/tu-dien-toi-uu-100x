[Video](https://wecommit.com.vn/courses/chuong-trinh-dao-tao-toi-uu-co-so-du-lieu-cao-cap/lesson/bai-doc-bo-tro-01/)

## Làm thế nào để phát hiện toàn bộ những Foreign Key chưa được đánh Index trong Cơ sở dữ liệu

Scripts sau sẽ giúp các bạn nhanh chóng rà soát toàn bộ các Tables có FK và chỉ ra chi tiết thông tin các tables chứa FK chưa được đánh Index

``` sql

```WITH
ref_int_constraints AS (
SELECT
col.owner,
col.table_name,
col.constraint_name,
con.status,
con.r_owner,
con.r_constraint_name,
COUNT(*) col_cnt,
MAX(CASE col.position WHEN 01 THEN col.column_name END) col_01,
MAX(CASE col.position WHEN 02 THEN col.column_name END) col_02,
MAX(CASE col.position WHEN 03 THEN col.column_name END) col_03,
MAX(CASE col.position WHEN 04 THEN col.column_name END) col_04,
MAX(CASE col.position WHEN 05 THEN col.column_name END) col_05,
MAX(CASE col.position WHEN 06 THEN col.column_name END) col_06,
MAX(CASE col.position WHEN 07 THEN col.column_name END) col_07,
MAX(CASE col.position WHEN 08 THEN col.column_name END) col_08,
MAX(CASE col.position WHEN 09 THEN col.column_name END) col_09,
MAX(CASE col.position WHEN 10 THEN col.column_name END) col_10,
MAX(CASE col.position WHEN 11 THEN col.column_name END) col_11,
MAX(CASE col.position WHEN 12 THEN col.column_name END) col_12,
MAX(CASE col.position WHEN 13 THEN col.column_name END) col_13,
MAX(CASE col.position WHEN 14 THEN col.column_name END) col_14,
MAX(CASE col.position WHEN 15 THEN col.column_name END) col_15,
MAX(CASE col.position WHEN 16 THEN col.column_name END) col_16,
par.owner parent_owner,
par.table_name parent_table_name,
par.constraint_name parent_constraint_name
FROM dba_constraints con,
dba_cons_columns col,
dba_constraints par
WHERE con.constraint_type = ‘R’
AND con.owner NOT IN (‘ANONYMOUS’,’APEX_030200′,’APEX_040000′,’APEX_SSO’,’APPQOSSYS’,’CTXSYS’,’DBSNMP’,’DIP’,’EXFSYS’,’FLOWS_FILES’,’MDSYS’,’OLAPSYS’,’ORACLE_OCM’,’ORDDATA’,’ORDPLUGINS’,’ORDSYS’,’OUTLN’,’OWBSYS’)
AND con.owner NOT IN (‘SI_INFORMTN_SCHEMA’,’SQLTXADMIN’,’SQLTXPLAIN’,’SYS’,’SYSMAN’,’SYSTEM’,’TRCANLZR’,’WMSYS’,’XDB’,’XS$NULL’,’PERFSTAT’,’STDBYPERF’,’MGDSYS’,’OJVMSYS’)
AND col.owner = con.owner
AND col.constraint_name = con.constraint_name
AND col.table_name = con.table_name
AND par.owner(+) = con.r_owner
AND par.constraint_name(+) = con.r_constraint_name
GROUP BY
col.owner,
col.constraint_name,
col.table_name,
con.status,
con.r_owner,
con.r_constraint_name,
par.owner,
par.constraint_name,
par.table_name
),
ref_int_indexes AS (
SELECT /*+ MATERIALIZE NO_MERGE */
r.owner,
r.constraint_name,
c.table_owner,
c.table_name,
c.index_owner,
c.index_name,
r.col_cnt
FROM ref_int_constraints r,
dba_ind_columns c,
dba_indexes i
WHERE c.table_owner = r.owner
AND c.table_name = r.table_name
AND c.column_position <= r.col_cnt
AND c.column_name IN (r.col_01, r.col_02, r.col_03, r.col_04, r.col_05, r.col_06, r.col_07, r.col_08,
r.col_09, r.col_10, r.col_11, r.col_12, r.col_13, r.col_14, r.col_15, r.col_16)
AND i.owner = c.index_owner
AND i.index_name = c.index_name
AND i.table_owner = c.table_owner
AND i.table_name = c.table_name
AND i.index_type != ‘BITMAP’
GROUP BY
r.owner,
r.constraint_name,
c.table_owner,
c.table_name,
c.index_owner,
c.index_name,
r.col_cnt
HAVING COUNT(*) = r.col_cnt
)
SELECT
*
FROM ref_int_constraints c
WHERE NOT EXISTS (
SELECT NULL
FROM ref_int_indexes i
WHERE i.owner = c.owner
AND i.constraint_name = c.constraint_name
)
ORDER BY
1, 2, 3;
```

## Không tạo index trên cột FK

- Hệ thống sẽ treo khi chưa commit Insert ở bảng con mà xóa bản ghi ở bảng cha. **Ngược lại thì không treo**

``` SQK
-- chỉ trace execution plan
SET AUTUTRACE TRACEONLY;
```

- Index ở bảng con có thể tăng tốc ở bảng cha.

## Demo

``` sql
-- tạo bảng cha
CREATE TABLE PARENT
(
PID INTEGER
);

ALTER TABLE PARENT
ADD (PRIMARY KEY (PID));
-- Tạo bảng con
CREATE TABLE CHILD
(
CID INTEGER
);

ALTER TABLE CHILD ADD (
FOREIGN KEY (CID)
REFERENCES PARENT (PID);
-- Insert dữ liệu
INSERT INTO PARENT VALUES(1) ;
INSERT INTO PARENT VALUES(2) ;
INSERT INTO PARENT VALUES(3) ;

COMMIT;
INSERT INTO CHILD VALUES (3);

COMMIT;

-- Kiểm tra dữ liệu
select * from parent;
select * from child;;
```

- tách thành 2 file query

``` SQL
nsert into child values(1);
```

``` sql
delete parent where pid=2;
```

- Câu lệnh ở Session 2 mặc dù cực kỳ đơn giản, bảng PARENT cũng có số lượng bản ghi rất nhỏ, tuy nhiên câu lệnh này bị “TREO” tại đây.
- Các bạn đăng nhập vào user quản trị của cơ sở dữ liệu và kiểm tra WAIT trong lúc này thì sẽ thấy kết quả như sau.
Câu lệnh kiểm tra WAIT:

``` SQL
SELECT EVENT, COUNT (*)
FROM GV$SESSION
WHERE BLOCKING_SESSION IS NOT NULL
GROUP BY EVENT
ORDER BY 2 DESC
```

Bạn thấy một điều thú vị ở đây là:

- Session thứ 2 thực hiện DELETE dữ liệu từ bảng PARENT ở bản ghi có giá trị bằng 2 (hoàn toàn không liên quan tới các bản ghi đang được làm việc – có giá trị bằng 1 tại bảng CHILD), tuy nhiên session vẫn bị LOCK.
- Session số 2 này sẽ treo VÔ TẬN, cho đến thời điểm Session số 1 kết thúc transaction (khi COMMIT hoặc ROLLBACK)
Bây giờ tôi sẽ thực hiện tạo Index trên cột đang là Foreign Key (cột CID của bảng CHILD) và thực hiện lại quá trình trên, chúng ta sẽ cùng chờ đợt kết quả sau khi sửa đổi nhé.

``` SQL
CREATE INDEX IDX_CID ON CHILD(CID);
```

- Thêm dữ liệu vào bảng Child

``` SQL
insert into child values(1);
```

- Xóa dl ở pareant

``` SQL
delete parent where pid=2;
```

- Câu lệnh đã hết treo

## Thêm nhiều dữ liệu

``` SQL
begin
for i in 4..1000000
loop
insert into parent values(i);
end loop;
commit;
end;
```

``` SQL
egin
for i in 4..1000000
loop
insert into child values(i);
end loop;
commit;
end;
```

- Thực hiện cập nhật thông tin về số lượng bản ghi cho Cơ sở dữ liệu biết (thuật ngữ gọi là gather statistics).

``` SQL
exec dbms_stats.gather_table_stats(ownname=>’HUYTQ’, tabname=>’PARENT’);
  exec dbms_stats.gather_table_stats(ownname=>’HUYTQ’, tabname=>’CHILD’);
```

- Xóa bản ghi ở parent

``` SQL
delete parent where pid=2;
```

- Câu lệnh thực hiện với thời gian cực kỳ nhanh (chỉ vài ms, hệ thống đánh giá là thời gian gần như tức thì 00:00:00)
–  Câu lệnh thực thi rất nhanh vì Oracle thực hiện chiến lược là quét INDEX UNIQUE SCAN
– Để thực hiện câu lệnh này, Cơ sở dữ liệu chỉ cần thực hiện khối lượng công việc là 3 consitent gets
Bây giờ chúng ta thử DROP INDEX trên bảng CHILD và thực hiện lại câu lệnh xem thế nào nhé

``` SQL
drop index IDX_CID;
```

``` SQL
delete parent where pid=2;
```

Tại đây ta có thể nhật thấy rằng:
– Thứ nhất: Trong demo hiện tại, câu lệnh cũng thực hiện cùng chiến lược thực thi là quét qua INDEX UNIQUE SCAN (giống với trước khi drop index)
– Thức hai: Thời gian chạy lúc này đã chậm hơn (cụ thể là đã thấy nổi lên: 00:00:01)
– Thứ ba: Khối lượng block cần duyệt lúc này đã tăng lên: từ 3 consitent gets trở thành 23 consistent gets (tăng 7.6 lần). Việc này cũng logic với kết quả thời gian của câu lệnh thực thi tăng lên
– Thức tư: Rõ ràng ở đây chúng ta chỉ làm việc với bảng PARENT, không hề có session nào động chạm tới bảng CHILD, nhưng kết quả khác biệt hoàn toàn giữa hai thời điểm: có INDEX và không có INDEX trên cột FK
Bản chất của sự KHÁC BIỆT rất lớn này là:
– Khi chúng ta muốn xóa dữ liệu ở bảng PARENT, Oracle sẽ có 1 suy nghĩ là “nhỡ chẳng may tồn tại giá trị đó ở bảng CHILD thì sao nhỉ, trường hợp này sẽ không được phép xóa giá trị ở bảng PARENT”. Như vậy Oracle sẽ cần tìm xem ở bảng CHILD có giá trị mà chúng ta đang xóa hay không (giá trị 2).
– Nếu không có Index trên FK, Oracle sẽ thực hiện quét toàn bộ bảng CHILD để tìm kết quả bên trên.
– Trong trường hợp có Index thì kết quả này sẽ nhanh hơn rất nhiều lần.
